//! Functionality for actually playing a mahjong match.

use crate::{messages::SessionId, tile::*};
use cs_bindgen::prelude::*;
use fehler::{throw, throws};
use maplit::hashmap;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, fmt::Debug};
use thiserror::Error;

#[cs_bindgen]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Match {
    pub id: MatchId,
    pub players: HashMap<Wind, Player>,

    /// The live wall that players will draw from.
    pub wall: Vec<Tile>,
}

impl Match {
    pub fn new(id: MatchId, tiles: Vec<Tile>) -> Self {
        Self {
            id,
            players: hashmap! {
                Wind::East => Player::new(),
                Wind::South => Player::new(),
                Wind::West => Player::new(),
                Wind::North => Player::new(),
            },

            // TODO: Split the dead wall from the live wall and draw out an initial hand.
            wall: tiles,
        }
    }

    /// Draws `count` tiles from the wall directly into a player's hand.
    ///
    /// If there are fewer than `count` tiles left in the wall, no tiles are drawn.
    #[throws(InsufficientTiles)]
    pub fn draw_for_player(&mut self, seat: Wind, count: usize) {
        let player = self.players.get_mut(&seat).unwrap();

        // Check if there are enough tiles for the draw before actually drawing any, that
        // way we don't have a partially-completed draw if there aren't enough tiles left.
        if self.wall.len() < count {
            throw!(InsufficientTiles::new(self.wall.len(), count));
        }

        for _ in 0..count {
            player.hand.push(self.wall.pop().unwrap());
        }
    }

    /// Draws the next tile from the wall and puts it in a player's draw slot.
    #[throws(InsufficientTiles)]
    pub fn draw_into_hand(&mut self, seat: Wind) {
        let player = self.players.get_mut(&seat).unwrap();

        let tile = self
            .wall
            .pop()
            .ok_or(InsufficientTiles::new(self.wall.len(), 1))?;

        player.current_draw = Some(tile);
    }
}

#[cs_bindgen]
impl Match {
    pub fn id(&self) -> u32 {
        // TODO: Directly return the value once cs-bindgen supports doing so.
        self.id.raw()
    }

    // TODO: Make the return type `&[Tile]` once cs-bindgen supports returning slices.
    pub fn get_player_hand(&self, seat: Wind) -> Vec<Tile> {
        self.players.get(&seat).unwrap().hand.clone()
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Error)]
#[error("Not enough tiles in wall for draw: {needed} tiles requested, but only {remaining} left")]
pub struct InsufficientTiles {
    remaining: usize,
    needed: usize,
}

impl InsufficientTiles {
    pub fn new(remaining: usize, needed: usize) -> Self {
        Self { remaining, needed }
    }
}

/// Unique identifier for an active match.
///
/// Values are generated by the server, and should not be created by the client.
#[cs_bindgen]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(transparent)]
pub struct MatchId(u32);

impl MatchId {
    pub fn new(id: u32) -> Self {
        Self(id)
    }

    pub fn raw(self) -> u32 {
        self.0
    }
}

/// Player state within a match.
#[cs_bindgen]
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Player {
    /// The client session controlling this player in the match, if any.
    ///
    /// If no client controls this player, then the player is CPU-controlled by default.
    pub controller: Option<SessionId>,

    /// The player's current hand.
    pub hand: Vec<Tile>,

    /// The player's current draw, if any.
    pub current_draw: Option<Tile>,

    /// The player's discard pile.
    pub discards: Vec<Tile>,
}

impl Player {
    /// Creates a new player will all default (i.e. empty) values.
    pub fn new() -> Self {
        Default::default()
    }
}
