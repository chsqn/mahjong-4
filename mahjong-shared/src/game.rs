//! Functionality for actually playing a mahjong match.

use crate::{messages::SessionId, tile::*};
use rand::Rng;
use std::fmt::Debug;

#[derive(Debug, Clone)]
pub struct Match<R: Rng> {
    pub id: MatchId,
    pub rng: R,
    pub players: [Player; 4],
}

impl<R: Rng> Match<R> {
    pub fn new(id: MatchId, rng: R) -> Self {
        Self {
            id,
            rng,
            players: [
                Default::default(),
                Default::default(),
                Default::default(),
                Default::default(),
            ],
        }
    }
}

/// Unique identifier for an active match.
///
/// Values are generated by the server, and should not be created by the client.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(transparent)]
pub struct MatchId(u32);

impl MatchId {
    pub fn new(id: u32) -> Self {
        Self(id)
    }

    pub fn raw(self) -> u32 {
        self.0
    }
}

/// Player state within a match.
#[derive(Debug, Clone, Default)]
pub struct Player {
    /// The client session controlling this player in the match, if any.
    ///
    /// If no client controls this player, then the player is CPU-controlled by default.
    pub controller: Option<SessionId>,

    /// The player's current hand.
    pub hand: Vec<Tile>,

    /// The player's current draw, if any.
    pub current_draw: Option<Tile>,

    /// The player's discard pile.
    pub discards: Vec<Tile>,

    /// The player's draw wall.
    pub wall: Vec<Tile>,
}

impl Player {
    /// Creates a new player will all default (i.e. empty) values.
    pub fn new() -> Self {
        Default::default()
    }

    /// Creates a new player with a pre-determined draw wall.
    pub fn with_wall(wall: Vec<Tile>) -> Self {
        Self {
            wall,
            ..Default::default()
        }
    }
}
